Credits to @ jstrosch for this CTF-like sample.

# Javascript - Deobfuscating a Turla JS Backdoor

## Objectives

In addition to common obfuscation techniques, malware authors will also use passwords to slow down analysis. Analyze this JavaScript file and see if you can deobfuscate the first stage! This JavaScript file was originally dropped by a malicious office document. 

*Please note - use of open-source intelligence will be needed to fully unravel this backdoor :)*

**The exercise files are in a password-protected archive using a password of:** ***infected***

## Challenge Solutions

### Sample - MD5: e12624fb6270a01eb8bb0308ce57ab45  

1. [What variable holds the next stage of code?](#what-variable-holds-the-next-stage-of-code)

2. [What function is responsible for executing the deobfuscated second stage?](#what-function-is-responsible-for-executing-the-deobfuscated-second-stage)

3. [What is the "key" needed to unravel the second stage?](#what-is-the-key-needed-to-unravel-the-second-stage)

4. [What does the function *LXv5* do?](#what-does-the-function-lxv5-do)

5. [What does the function *CpPT* do?](#what-does-the-function-ccpt-do)

## What variable holds the next stage of code?

Begin by opening the JS file in a text editor, you want to see if you can observe anything about the code and its structure.

<img alt="" src="images/finding_nextstage.png" width="800">

It is certainly using obfuscation, there isn’t much code in the beginning of the file but there is a large string (the orange color in the thumbnail view). Likely, this is the next round of JS and the code we’re looking at now is there simply to deobfuscate it. 

<img alt="" src="images/secondstage_variable.png" width="800">

And there it is - the function *y3zb* returns the value of the variable *qGxZ*, which is assigned the long string value. You could move to dynamic analysis at this point – but before we do that let’s look at the JavaScript in more detail. 

## What function is responsible for executing the deobfuscated second stage?

Our next goal is to find the entry point, this is the beginning of the file. This code starts in a try block:

<img alt="" src="images/entrypoint.png" width="800">

After a few instructions there is a call to *eval*, this is a commonly used function with interpreted languages. The new JavaScript is built and passed as an argument to eval, which treats the string as JavaScript and executes it. You can now modify the JS file and use cscript (or wscript) to execute it. Comment out the eval statement and add an Echo statement, then use cscript to execute it:

<img alt="" src="images/echo.png" width="800">

Hm, nothing happened. Look at the code in more detail, you’ll notice that the first statement uses *WScript.Argument*, perhaps this script expects an argument when invoked? The argument is assigned to *wvy1*, which is then used to access the first element (wvy1(0)) and assigned to the variable *ssWZ*. This value is then provided as an argument to the call to *CpPT*. Run the script again with a command line argument:

<img alt="" src="images/testarg.png" width="800">

Output! But nothing that seems like JavaScript, since this is intended to be executed by eval we must still be missing something – the key to deobfuscate the internal JS.

## What is the key needed to unravel the second stage?

This JavaScript was dropped and executed by a malicious office document, which means that the office document would be able to provide the correct key when it was invoked. Try using open source to find this key, such as VirusTotal, Hybrid-Analysis and others. Sandboxes are a good place to look for runtime information, here is the process activity as reported by Hybrid-Analysis:

<img alt="" src="images/maldoc.png" width="800">

Still the same problem though, there is no key. We need to find the office document responsible for dropping this file, how are we going to do that?

Searching by hash will likely just return results for that specific JS file. Try searching on parts of the JS itself, such as "function CpPT(bOe3,F5vZ) word”, I included the keyword “word” to help focus my results. 

<img alt="" src="images/thekey.png" width="800">

Results on [HybridAnalysis](https://www.hybrid-analysis.com/sample/ff2c8cadaa0fd8da6138cce6fce37e001f53a5d9ceccd67945b15ae273f4d751?environmentId=100)

You could also get creative and find the key on [Twitter](https://twitter.com/johnlatwc/status/915590893155098629)

And there’s our key! *EzZETcSXyKAdF_e5I2i1*. Try this key with the modified JS and see if you get different results.

<img alt="" src="images/stage2.png" width="800">

There’s the next stage. You can redirect this output to a file using the redirection operator “>”:

<img alt="" src="images/redirect.png" width="800">

And now are able to analyze the next stage in your text editor:

<img alt="" src="images/unraveled.png" width="800">

But what did those initial functions do? Let's take a closer look.

## What does the function LXv5 do?

At this point, we really didn't spend any time on the string itself, nor any of the logic used to deobfuscated it. The main reason for this is that by replacing *eval* with *echo*, we were able to quickly unravel the next stage. However, it's important to recognize some of the functionality that was used to unravel this second stage. Let's start with function *LXv5*. But before we do that, you may have noticed that the string contains a limited character set - which is a sign of *Base64* encoding. When I suspect this, I almost always check the end of the string for *=* characters. Base64 is based on defined block sizes and if the string ends without filling the last block, it will be padded with one or two equal signs. This string ends with an equal sign, so very likely it's base64 encoded:

<img alt="" src="images/encoding_tell.png" width="800">

We could simply decode this string and see what happens. But before we do that, let's look at the function. The function *LXv5* contains a tell-tale string assigned to the variable *LUK7*:

<img alt="" src="images/base64_charset.png" width="800">

This is the common character set used for base64 encoding and is a strong indicator that this function is an implementation of base64 decoding. It's not only common to see these direct implementations (versus using a more recognizable library function, such as *base64_decode*), but malware authors can also use custom character sets to slow down your analysis. Let's take this string to CyberChef and decode it:

<img alt="" src="images/cyberchef.png" width="800">

Great - it decoded but to nothing that is recognizable. Well, the results are passed to the function *CpPT*, so let's move our analysis to that.

## What does the function CpPT do?

From our initial analysis, we know that this function takes two arguments - the base64 decoded string and the key. This alone could lead you to think an encyrption algorithm, and simple ones like RC4 are commonly used for tasks such as these. Of course, we could just go right to CyberChef and test our theory but let's look at the code a bit first.

I find that formatting code can often lead to more obvious patterns - and ultimately it's purpose.

<img alt="" src="images/rc4.png" width="800">

And then, testing the RC4 theory, do a little digging online. Resources like [Wikipedia](https://en.wikipedia.org/wiki/RC4) can be helpful. You can also look for code samples on places like [Github](https://gist.github.com/farhadi/2185197):

<img alt="" src="images/sample_code.png" width="800">

And that looks almost identical! To CyberChef we go - building on to our previous recipe, we can add the RC4 decrypt operation and...

<img alt="" src="images/rc4_win.png" width="800">

There is our second stage! So we looked at two different ways of unraveling this obfuscation using static and dynamic analysis. Often times the approach you choose will be based on how quickly you want to move along your analysis. However, it may not always be that straight-forward and recognizing encoding and encryption functions can help you immensely.
